<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simulation of HDX data • powerHaDeX</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Simulation of HDX data">
<meta property="og:description" content="powerHaDeX">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">powerHaDeX</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Example_simulation.html">Simulation - example usage</a>
    </li>
    <li>
      <a href="../articles/Simulation_description.html">Simulation of HDX data</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="Simulation_description_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Simulation of HDX data</h1>
            
      
      
      <div class="hidden name"><code>Simulation_description.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">powerHaDeX</span><span class="op">)</span></code></pre></div>
<p>The package <code>powerHaDeX</code> is a tool providing a solution for the need for simulation and analysis of the data coming from HDX-MS experiments. This article is dedicated to the detailed description of the simulation of HDX-MS data.</p>
<div id="diagram-of-hdx-ms-curve-simulation-" class="section level1">
<h1 class="hasAnchor">
<a href="#diagram-of-hdx-ms-curve-simulation-" class="anchor"></a>Diagram of HDX-MS curve simulation.</h1>
<p>The simulation was created in such a way that it imitates the real experiment as much as it is possible. To obtain the deuterium uptake at a single time point, one has to compute a mass spectrum first. Thus, the simulation consists of two main parts. The first one concerns the biological section of calculations, that is simulation of theoretical spectra, and the second concerns calculating deuteration curves and multiplying the data for the need for power simulation.</p>
<ol style="list-style-type: decimal">
<li>Simulate theoretical spectrum</li>
<li>Add noise to the theoretical spectrum
<ul>
<li>Making replicated theoretical spectra</li>
<li>Calculating deuterium uptake curves from replicated spectra</li>
<li>Making replicated deuterium uptake curves (power estimation)</li>
</ul>
</li>
</ol>
<p>The diagram of the simulation algorithm can be seen in the figure below:</p>
<center>
<img src="sim.png" title="fig:" width="600" alt="Simulation algorithm">
</center>
<p>The parameters sequence, charge, state, and time point define, simplistically, a unique mass spectrum. Thus, as shown in the above figure, having two different biological states and <span class="math inline">\(T\)</span> different exposure times we obtain <span class="math inline">\((2 \times T)\)</span> unique spectra. From now on such a set will identify one <strong>replication</strong>. This part of the simulation is described in detail in the section <strong>Simulate theoretical spectrum</strong>. The next step of the simulation is reproducing the number of replications. First, we add noise to the obtained spectra and transform each of them into deuterium uptake. The deuterium uptake at different time points forms the deuterium uptake curve. The set of replicated deuterium uptake curves for different states is the target of the simulation. The procedure is described in <strong>Add noise to the theoretical spectrum</strong>.</p>
<div id="simulate-theoretical-spectrum" class="section level2">
<h2 class="hasAnchor">
<a href="#simulate-theoretical-spectrum" class="anchor"></a>1. Simulate theoretical spectrum</h2>
<p>The algorithm that is used to simulate theoretical spectra is based on Zhong-Yuan Kan’s implementation in MATLAB. The original version of codes is located in the repository <a href="https://github.com/kanzy/HX-MS-Simulations">HX-MS-Simulations</a> (as at 29.06.2020). In the <code>powerHaDeX</code> package can be found the Kan’s algorithm re-implemented in R (using Rcpp) and the accelerated implementation (that uses Markov chains’ properties). Moreover, the package <code>powerHaDeX</code> allows the user to simulate spectra for more than one exposure time for both (Rcpp and Markov) approaches.</p>
<div id="elements-of-the-code" class="section level3">
<h3 class="hasAnchor">
<a href="#elements-of-the-code" class="anchor"></a>Elements of the code</h3>
<p>The simulation code is in <code>simulate_theoretical_spectra.R</code> file. It uses the following internal functions:</p>
<ol style="list-style-type: decimal">
<li>get_approx_isotopic_distribution (<code>isotopic_distribution.R</code>),</li>
<li>get_exchange_rates (<code>exchange_rates.R</code>),</li>
<li>get_exchange_probabilities (<code>simulate_HD_exchange.R</code>),</li>
<li>get_HD_matrices_using_markov / get_HD_matrices (<code>simulate_HD_exchange.R</code>),</li>
</ol>
<div id="parameters-needed-to-run-the-simulation" class="section level4">
<h4 class="hasAnchor">
<a href="#parameters-needed-to-run-the-simulation" class="anchor"></a>Parameters needed to run the simulation</h4>
<p>The simulation is run for a given peptide. The parameters are:</p>
<ul>
<li><p><code>sequence</code> - sequence of the peptide, single string. Necessary to run the simulation.</p></li>
<li><p><code>charge</code> - a vector of charges of the peptide ion. If NULL, one value is sampled from vector 2:6. Default value: NULL.</p></li>
<li><p><code>times</code> - vector of time points of the measurement. Default value: vector of 60 and 600 [seconds]</p></li>
<li><p><code>protection_factor</code> - protection factor - vector of values or one value for all amides. Default value: 1 (indicates that the exchange rate is equal to the intrinsic exchange rate)</p></li>
<li><p><code>pH</code> - pH. Default value: 7.5</p></li>
<li><p><code>temperature</code> - temperature. Default value: 15 [Celcius]</p></li>
<li><p><code>n_molecules</code> - number of peptide molecules. Default value: 100</p></li>
<li><p><code>time_step_const</code> - time step constant. Default value: 1. Value that indicates the length of the time step of the simulation. The bigger the time step, the fewer time points are simulated (the fewer iterations in case of Zhong-Yuan Kan’s approach).</p></li>
<li><p><code>if_corr</code> - logical, pH correction indicator. If FALSE, then the value of pH is equal to pD. If there is correction, the pD = pH + 0.4.(Connelly et al. 1993)</p></li>
<li><p><code>min_probability</code> - minimal accepted probability. Default value: <span class="math inline">\(10^{-4}\)</span>, threshold for accepting the values of the isotopic probabilities (intensity).</p></li>
<li><p><code>use_markov</code> - usage of Markov chains indicator. Default value: TRUE, as it fastens the calculation</p></li>
</ul>
</div>
<div id="how-the-simulation-works" class="section level4">
<h4 class="hasAnchor">
<a href="#how-the-simulation-works" class="anchor"></a>How the simulation works</h4>
<p>The graphical illustration of the algorithm can be seen in the figure below. As said, the procedure that we describe below is based on Kan’s implementation. However, the section of the simulation called <strong>Calculate matrices of simulated empirical distribution</strong> appears in this thesis in two versions. The second version is the standard approach of Zhong-Yuan Kan, additionally implemented in Rcpp (called when use_markov = FALSE), and the first version is the algorithm accelerated for the needs for this thesis.</p>
<center>
<img src="alg.png" title="fig:" width="500" alt="Simulation algorithm">
</center>
</div>
<div id="prepare-essential-parameters-" class="section level4">
<h4 class="hasAnchor">
<a href="#prepare-essential-parameters-" class="anchor"></a>Prepare essential parameters.</h4>
<p>Initially parameter <code>sequence</code> is split into a character vector. From now, <code>sequence</code> will indicate the vector of amino acids and n will denote its length. If a single value of <code>protection_factor</code> is provided, the vector of that value of the length of the <code>sequence</code> is created. If no value of <code>charge</code> is provided, it is assigned randomly from the range from 2 to 6.</p>
</div>
<div id="calculate-the-isotopic-distribution-of-an-undeuterated-peptide-that-is-required-to-get-an-empirical-distribution-" class="section level4">
<h4 class="hasAnchor">
<a href="#calculate-the-isotopic-distribution-of-an-undeuterated-peptide-that-is-required-to-get-an-empirical-distribution-" class="anchor"></a>Calculate the isotopic distribution of an undeuterated peptide that is required to get an empirical distribution.</h4>
<p>The function <code>get_approx_isotopic_distribution</code> is responsible for calculation of approximate isotopic distribution. The function takes two arguments: <code>sequence</code> and <code>min_probability</code>.</p>
<p>Additional file <code>sysdata.RDA</code> contains the maximal possible occurrence of the isotopes <span class="math inline">\(C_{13}\)</span>, <span class="math inline">\(N_{15}\)</span>, <span class="math inline">\(O_{18}\)</span>, <span class="math inline">\(S_{34}\)</span> (carbon, nitrogen, oxygen, and sulfur, respectively) in the respective amino acids, and their masses. Based on that, the maximal possible number of molecules of the isotopes in the sequence is calculated. Peptide mass is the sum of the masses of amino acids and <span class="math inline">\(H_2O\)</span> mass - as it includes the N terminal group (H) and C terminal group (OH).</p>
<p>Next, the distributions of mentioned isotopes are calculated under the assumption that the occurrence of <span class="math inline">\(i^{th}\)</span> considered isotope has a binomial distribution <span class="math inline">\(B(n_i, p_i)\)</span> with parameters <span class="math inline">\(n_i\)</span> (maximal possible occurrence in the sequence) and <span class="math inline">\(p_i\)</span> (natural richness - possibility of occurrence in the universe). For the oxygen molecules, we have to take into account that oxygen occurs in a diatomic molecule. Calculation of the sulfur distribution takes into account its rare occurrence.</p>
<p>The final isotopic distribution is computed as a convolution of obtained distributions with probabilities greater than <code>min_probability</code>. It is a vector of probabilities of possible monoisotopic masses. The number of exchangeable amides is computed as the length of the sequence, reduced by the number of prolines located on the third of further position.</p>
<p>The function <code>get_approx_isotopic_distribution</code> returns the mass of the peptide (<code>peptide_mass</code>), final distribution (<code>isotopic_distribution</code>) of the isotopes, number of significant probabilities minus one (<code>max_ND</code>) and number of exchangeable amino acids (<code>n_exchangeable</code>).</p>
</div>
<div id="calculate-exchange-rates-that-are-required-to-obtain-exchange-probabilities-" class="section level4">
<h4 class="hasAnchor">
<a href="#calculate-exchange-rates-that-are-required-to-obtain-exchange-probabilities-" class="anchor"></a>Calculate exchange rates that are required to obtain exchange probabilities.</h4>
<p>Calculation of the exchange rates is one of the crucial parts of the simulation because the exchange rates (kinetic constants) affect the exchange probabilities. The calculations are done via <code>get_exchange_rates</code> function. The adjunctive calculations take place in the internal functions from <code>exchange_rates</code> file. Namely:</p>
<ul>
<li><p><code>get_F_const</code> uses two parameters: <code>temp_kelvin</code> (initial <code>temperature</code> parameter in celcius converted into temperature in kelvin) and <code>gas_constant</code> which is <span class="math inline">\(1.9858775\)</span>. The value <span class="math inline">\(Q_7\)</span> is a factor adjusted to the measured temperature and is calculated based on the equation below. <span class="math display">\[Q_7 = \dfrac{1}{gas\_constant}\left( \dfrac{1}{temp\_kelvin} - \dfrac{1}{293}\right)\]</span> The output of <code>get_F_const</code> is a list of <span class="math display">\[Ft_X = \exp\lbrace-Q_7 \cdot Ea_X\rbrace\]</span> where <span class="math inline">\(X \in \lbrace A, B, W\rbrace\)</span> (A - Acid, B - Base, W - Water) identifies the condition and <span class="math inline">\(Ea_A, Ea_B, Ea_W\)</span> are tabular values for energies of activation.</p></li>
<li><p><code>get_poly_const</code> calculates constants depending on provided <code>mol_type</code> and type of exchange - <code>exchange</code> (<span class="math inline">\(HD\)</span> or <span class="math inline">\(DH\)</span>, default to <span class="math inline">\(HD\)</span>). If the <code>mol_type</code> is <span class="math inline">\(poly\)</span> then the constant for condition <span class="math inline">\(X\)</span> is calculated as follows <span class="math display">\[K_{Xpoly} = \dfrac{10^{K_{X_{exp}}}}{60}\]</span> where <span class="math inline">\(K_{X_{exp}}\)</span> are tabular constants depending on the type of exchange. If <code>mol_type</code> is <span class="math inline">\(oligo\)</span>, the constants are scaled accordingly: <span class="math display">\[K_{Xoligo} = K_{Xpoly} \cdot c_X\]</span> where <span class="math inline">\(c_X\)</span> are constants <span class="math inline">\(2.34\)</span>, <span class="math inline">\(1.35\)</span> and <span class="math inline">\(1.585\)</span> for acid, base and water, respectively. The function returns a list of <span class="math inline">\(Ka\)</span>, <span class="math inline">\(Kb\)</span> and <span class="math inline">\(Kw\)</span> corresponding to the chosen <code>mol_type</code>.</p></li>
<li>
<p><code>get_pkc</code> calculates supplementary constants for aspartic acid (Asp), glutamic acid (Glu) and histidine (His). Values for mentioned amino acids are pH and temperature dependent, in contrary to the rest amino acids with fixed values. This function needs <code>temp_kelvin</code> value, <code>gas_constant</code> and the type of <code>exchange</code> (default: <span class="math inline">\(HD\)</span>).</p>
<p>Depending on provided <code>exchange</code> direction tabular values of exponents <span class="math inline">\(E_{const}\)</span> are assigned. For Asp, Glu and His the <span class="math inline">\(pKc\)</span> constants are calculated based on the following formula: <span class="math display">\[pKc = -\log_{10}\left(10^{E_{const}} \cdot \exp\Bigg\lbrace \dfrac{-E_a}{gas\_constant}\left( \dfrac{1}{temp\_kelvin} - \dfrac{1}{278}\right)\Bigg\rbrace\right)\]</span> where <span class="math inline">\(E_a\)</span> are energies off activation for given amino acid and the chosen <code>exchange</code> direction. The function returns a list of <span class="math inline">\(asp\)</span>, <span class="math inline">\(glu\)</span> and <span class="math inline">\(his\)</span> (<span class="math inline">\(pKc\)</span> values corresponding to amino acids).</p>
</li>
<li><p><code>get_exchange_constants</code> uses the parameters <code>pH</code>, <code>pkc_consts</code> calculated by the function <code>get_pkc</code> and <code>k_consts</code>. The output of <code>get_exchange_constants</code> is a matrix named <code>constants</code> of tabular and calculated constants (specifically for <span class="math inline">\(Asp\)</span>, <span class="math inline">\(Glu\)</span>, <span class="math inline">\(His\)</span>, <span class="math inline">\(C-Term\)</span> and <span class="math inline">\(NHMe\)</span>) based on the equation: <span class="math display">\[const = \log_{10}\left( \dfrac{10^{c_1 - pH} + 10^{c_2 - pKc}}{10^{-pKc} + 10^{-pH}}\right)\]</span> where <span class="math inline">\(c_1\)</span> and <span class="math inline">\(c_2\)</span> are constants for protonated or deprotonated amide and <span class="math inline">\(pKc\)</span> are constants obtained by the function <code>get_pkc</code> for respective acids.</p></li>
</ul>
<p>The function <code>get_exchange_rates</code> requires the parameters <code>sequence</code>, <code>exchange</code> (default: <span class="math inline">\(HD\)</span>), <code>pH</code> (default: <span class="math inline">\(9\)</span>), <code>temperature</code> (celcius, default: <span class="math inline">\(15\)</span>), <code>mol_type</code> (default: <span class="math inline">\(poly)\)</span> and correction factor <code>if_corr</code> (<span class="math inline">\(1\)</span> or 0, default: 0). The correction of <span class="math inline">\(pH\)</span> is taken into account for calculation of <span class="math inline">\(pD\)</span>: <span class="math display">\[pD = pH + 0.4\cdot if\_corr.\]</span></p>
<p>Next, the provided temperature is converted into K and the internal functions <code>get_F_const</code>, <code>get_poly_const</code> and <code>get_pkc</code> are evaluated.</p>
<p>Using the obtained matrix of constants and provided <code>sequence</code> <span class="math inline">\(F_a\)</span> and <span class="math inline">\(F_b\)</span> are calculated for each amino acid in the sequence, concerning the previous and next amino acid. For the amino acids in the middle of the sequence, the following formula is used: <span class="math display">\[F_x = 10^{ previous_x + current_x}\]</span> where <span class="math inline">\(x\)</span> is either <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span>, and <span class="math inline">\(previous_x\)</span> is the acid/base factor for a previous amino acid in the sequence, and <span class="math inline">\(current_x\)</span> for the amino acid it is calculated for. If the amino acid is next to the C- or N-term, the term-effect is taken into account.</p>
<p>Finally, the exchange rate <span class="math inline">\(k_c\)</span> for the amino acid is the sum of catalysis constants for acid, base and water (Conelly et al, 1993). Namely: <span class="math display">\[k_c = k_{acid} + k_{base} + k_{water}\]</span> where <span class="math display">\[k_{acid} = F_a \cdot K_a + D \cdot F_{ta},\]</span> <span class="math display">\[k_{base} = F_b \cdot K_b + OD \cdot F_{tb},\]</span> <span class="math display">\[k_{water} = F_b \cdot K_w \cdot F_{tw}. \]</span> where <span class="math inline">\(D\)</span> and <span class="math inline">\(OD\)</span> indicates deuterium and deuterium oxide concentration, <span class="math inline">\(F_a\)</span> and <span class="math inline">\(F_b\)</span> are values calculated specifically for given amino acid, as described before, <span class="math inline">\(K_a\)</span> and <span class="math inline">\(K_b\)</span> are values computed by <code>get_poly_constants</code> function, based on the mole type, <span class="math inline">\(F_{ta}\)</span>, <span class="math inline">\(F_{tb}\)</span> and <span class="math inline">\(F_{tw}\)</span> are values computed by <code>get_F_const</code> function.</p>
<p>The obtained exchange rates are stored in vector <code>kcHD</code> or <code>kcDH</code> according to the exchange direction. They are used to calculate the exchange probabilities thus both <code>kcHD</code> and <code>kcDH</code> are necessary as we take the possibility of back-exchange into account.</p>
</div>
<div id="prepare-time-points-of-possible-exchanges-" class="section level4">
<h4 class="hasAnchor">
<a href="#prepare-time-points-of-possible-exchanges-" class="anchor"></a>Prepare time points of possible exchanges.</h4>
<p>To obtain time points (not to be confused with time points of the measurement) of possible exchanges, two parameters are necessary: <code>time_step_constant</code> and exchange rates computed by <code>get_exchange_rates</code> function (described before).</p>
<p>To calculate the size of a single time step, the maximal possible exchange rate <span class="math inline">\(k_{max}\)</span> is needed:</p>
<p><span class="math display">\[k_{max} = \max\lbrace\max\lbrace k_{cDH} \rbrace, \max\lbrace k_{cHD}\rbrace\rbrace\]</span> where <span class="math inline">\(k_{cHD}\)</span> and <span class="math inline">\(k_{cDH}\)</span> are the vectors of exchange rates for each amino acid from the sequence in the appropriate direction. The size of a time step is a quotient of <code>time_step_constant</code> and maximal exchange rate <span class="math inline">\(k_{max}\)</span></p>
<p><span class="math display">\[\Delta t = \dfrac{time\_step\_constant}{k_{max}}.\]</span></p>
<p>The time points of possible exchanges are arithmetic sequences from 0 to chosen time points of measurement <code>times</code> by <span class="math inline">\(\Delta t\)</span>. Let us note here for the first time that in the case when the obtained <span class="math inline">\(\Delta t\)</span> is very small, we encounter a problem with allocating a large vector of time sequence in R. The length of this sequence is the number of time points of possible exchanges. The vector of the number of steps between provided times of measurement is constructed for the Markov chain approach.</p>
</div>
<div id="calculate-probabilities-of-exchanges-that-are-required-to-simulate-the-exchange-process-" class="section level4">
<h4 class="hasAnchor">
<a href="#calculate-probabilities-of-exchanges-that-are-required-to-simulate-the-exchange-process-" class="anchor"></a>Calculate probabilities of exchanges that are required to simulate the exchange process.</h4>
<p>Exchange probabilities are calculated via <code>get_exchange_probabilities</code> function. The essential parameters are <code>protection_factor</code>, exchange rates <span class="math inline">\(k_{cHD}\)</span> and <span class="math inline">\(k_{cDH}\)</span> and the size of a single time step <span class="math inline">\(\Delta t\)</span>. The process is defined as a series of steps from the time sequence, and each step depends on the state in the previous one. Therefore, the probabilities of changing the state are conditional probabilities - probabilities of particular state in <span class="math inline">\((k+1)^{th}\)</span> step given particular state in <span class="math inline">\(k^{th}\)</span> step. For simplification the following notation is used:</p>
<p><span class="math display">\[P(X_{k+1} = H ~|~ X_{k} = H) = P\left( H \rightarrow H \right),\]</span> <span class="math display">\[P(X_{k+1} = D ~|~ X_{k} = H) = P\left( H \rightarrow D \right),\]</span> <span class="math display">\[P(X_{k+1} = H ~|~ X_{k} = D) = P\left( D \rightarrow H \right),\]</span> <span class="math display">\[P(X_{k+1} = D ~|~ X_{k} = D) = P\left( D \rightarrow D \right),\]</span></p>
<p>where <span class="math inline">\(X_k\)</span> is the random variable describing the state of an isotope of a hydrogen (<span class="math inline">\(H\)</span> or <span class="math inline">\(D\)</span>) at the moment <span class="math inline">\(k\)</span> for any <span class="math inline">\(k\)</span> from the considered time sequence. The probabilities for the <span class="math inline">\(i^{th}\)</span> amino acid, <span class="math inline">\(i = 1, \ldots, n\)</span>, are calculated by equations below.</p>
<p><span class="math display">\[P_i\left( H \rightarrow D \right) = 1 - \text{exp}\left(\dfrac{-kcHD_i \cdot \Delta t}{Pf}\right)\]</span>,</p>
<p><span class="math display">\[P_i\left( D \rightarrow H \right) = 1 - \text{exp}\left(\dfrac{-kcDH_i \cdot \Delta t}{Pf}\right)\]</span> where <span class="math inline">\(Pf\)</span> denotes the protection factor. Moreover, let us note that under the assumptions mentioned before, the following equations are satisfied: <span class="math display">\[P_i\left( H \rightarrow H \right) = 1 - P_i\left( H \rightarrow D \right),\]</span> <span class="math display">\[P_i\left( D \rightarrow D \right) = 1 - P_i\left( D \rightarrow H \right).\]</span></p>
<p>The last two equations describe the probabilities of staying in the same state.</p>
<p>The output of <code>get_exchange_probabilities</code> function is a list of four vectors: vector <code>HD</code> for probabilities <span class="math inline">\(P_i\left( H \rightarrow D \right)\)</span>, vector <code>DH</code> for probabilities <span class="math inline">\(P_i\left( D \rightarrow H \right)\)</span>, vector <code>HH</code> for probabilities <span class="math inline">\(P_i\left( H \rightarrow H \right)\)</span> and vector <code>DD</code> for probabilities <span class="math inline">\(P_i\left( D \rightarrow D \right)\)</span>.</p>
</div>
<div id="calculate-matrices-of-simulated-exchange-required-for-obtaining-empirical-distribution-" class="section level4">
<h4 class="hasAnchor">
<a href="#calculate-matrices-of-simulated-exchange-required-for-obtaining-empirical-distribution-" class="anchor"></a>Calculate matrices of simulated exchange required for obtaining empirical distribution.</h4>
<p>Matrices of simulated exchange can be obtained in two ways. The parameter <code>markov</code> indicates whether Markov chain or standard approach is used. Due to the evaluation time, the recommended method is the Markov chain approach. The following items <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span> are the descriptions of the improved and the standard version, respectively. Each of them is an interchangeable part of the simulation.</p>
<ol style="list-style-type: decimal">
<li><p>The improved version of the simulation uses <code>get_HD_matrices_using_markov</code> function. It requires <code>sequence</code>, transition probabilities (described in the previous section), the vector of numbers of steps between given time points, and the number of peptide molecules <code>n_molecules</code>. The improvement is based on the observation that the considered process is a Markov chain with transition probabilities <span class="math inline">\(P(H \rightarrow D)\)</span> and <span class="math inline">\(P(D \rightarrow H)\)</span>, and states <span class="math inline">\(H\)</span> and <span class="math inline">\(D\)</span> (in the code denoted by <span class="math inline">\(0's\)</span> for hydrogens and <span class="math inline">\(1's\)</span> for deuters). Based on the notation provided before, the transition matrix for the <span class="math inline">\(i^{th}\)</span> amino acid, <span class="math inline">\(i = 1, \ldots, n\)</span>, is created as follows: <span class="math display">\[\mathbb{P}_i = \begin{pmatrix}
     P_i\left( H \rightarrow H \right) &amp; P_i\left( H \rightarrow D \right) \\
     P_i\left( D \rightarrow H \right) &amp; P_i\left( D \rightarrow D \right)
     \end{pmatrix} = \begin{pmatrix}
     1 - P_i\left( H \rightarrow D \right) &amp; P_i\left( H \rightarrow D \right) \\
     1 - P_i\left( D \rightarrow H \right) &amp; P_i\left( D \rightarrow H \right)
     \end{pmatrix}.\]</span> The initial state of the process is <span class="math inline">\(\mu_i^T(0) = \begin{pmatrix} 1&amp; 0\end{pmatrix}\)</span> for all <span class="math inline">\(i\)</span>, as it starts with hydrogens. Since <span class="math inline">\(\mathbb{P}_i^k\)</span> is equal to the <span class="math inline">\(k\)</span>-step transition probability matrix, the probability distribution of the Markov chain at a time <span class="math inline">\(k\)</span> can be found as described in equation below. <span class="math display">\[\mu_i^T(k) = \mu_i^T(0) \mathbb{P}_i^k = \begin{pmatrix} P_i(X_k = H)\\ P_i(X_k = D)\end{pmatrix} ^ T.\]</span> Using obtained distribution, states <span class="math inline">\(H\)</span> or <span class="math inline">\(D\)</span> are sampled for <span class="math inline">\(m\)</span> peptide molecules (<code>n_molecules</code>) for each of <span class="math inline">\(i = 1, \ldots, n\)</span> amino acids and stored in a <span class="math inline">\(m \times n\)</span> dimensional matrix for each of the time points of the measurement given by <code>times</code>.</p></li>
<li>
<p>The standard version of simulation of the matrices uses <code>get_HD_matrices</code> function. The parameters are <code>sequence</code>, transition probabilities, time steps sequence (from 0 to the largest value of <code>times</code> by <span class="math inline">\(\Delta t\)</span>) and the time points of the measurement <code>times</code>. Since this version uses the vector of time steps, there occurs an error in case when <span class="math inline">\(\Delta t\)</span> is small (i.e. for long sequences or small <code>time_step_constant</code>).</p>
<p>The provided time sequence is split into intervals between time points of the measurement (<code>times</code>) to make the simulation faster in case of more than one time point of the measurement. In such a situation, an exchange to the next time point is obtained as an exchange to the previous time point and its continuation. The simulation starts with the creation of a matrix of dimension <span class="math inline">\(m \times n\)</span>, where <span class="math inline">\(m\)</span> denotes the number of peptide molecules (<code>n_molecules</code>) and <span class="math inline">\(n\)</span> denotes the number of amino acids. Each entry of this matrix corresponds to a single exchange site. Within the matrix, 0 denotes hydrogen and <span class="math inline">\(1\)</span> denotes deuterium. The matrix is initialized with 0s or <span class="math inline">\(1\)</span>s, depending on the direction of the exchange.</p>
<p>The matrix is initialized with zeroes, as a considered process it starts with hydrogens. At each time point in the time sequence:</p>
<ul>
<li>change <span class="math inline">\(1\)</span> to 0 with probability <span class="math inline">\(P(H \rightarrow D)\)</span> in each entry of the matrix from the previous iteration,</li>
<li>change <span class="math inline">\(1\)</span> to 0 with probability <span class="math inline">\(P(D \rightarrow H)\)</span> in each entry of the matrix from the previous iteration.</li>
</ul>
<p>Such a matrix is obtained for each of the time points of the measurement given by <code>times</code>.</p>
</li>
</ol>
<p>Next, no matter which version of the simulation was chosen, the columns of the matrices respective to prolines or the first two amides are set to zeros (implying hydrogens). The exchange of the first two amino acids is not measurable due to the impact of back-exchange (Connelly et al. 1993) and proline does not have exchangeable hydrogen. Matrices are stored in a list of matrices (<code>HD_matrices</code>) - each matrix for the respective time point of the measurement <code>times</code>.</p>
</div>
<div id="calculate-isotopic-probabilities-intensity-and-mass-to-charge-ratio-mz-" class="section level4">
<h4 class="hasAnchor">
<a href="#calculate-isotopic-probabilities-intensity-and-mass-to-charge-ratio-mz-" class="anchor"></a>Calculate isotopic probabilities (intensity) and mass-to-charge ratio (<span class="math inline">\(m/z\)</span>).</h4>
<p>Isotopic probabilities are calculated via <code>get_iso_probs_deut</code>. The function uses the parameters described before: <code>HD_matrices</code>, <code>n_exchangeable</code>, <code>isotopic_distribution</code>, <code>max_ND</code>, <code>peptide_mass</code> and the essential parameters: <code>charge</code>, <code>pH</code> and <code>times</code>.</p>
<p>The following calculations are performed for each time point of the measurement from <code>times</code>.</p>
<ul>
<li><p>Firstly, an observed distribution of ions is computed using the internal function <code>get_observed_iso_dist</code>. It takes parameters: HD matrix (element of the list of <code>HD_matrices</code>), <code>isotopic_distribution</code> and <code>n_exchangeable</code>.</p></li>
<li><p>The exchangeable-hydrogen distribution describing the increase of the mass is obtained from the exchange matrix from <code>HD_matrices</code> and the number of exchangeable hydrogens <code>n_exchangeable</code>. First, the numbers of hydrogens exchanged in each molecule are calculated as sums of rows of the exchange matrix. Next, a vector of the counts is built and stored in a vector of length <code>n_exchangeable</code> plus one (for the lack of exchange). To obtain fractions counts are averaged.</p></li>
<li><p>The isotopic probabilities for the deuterated peptide are computed as the convolution of obtained distribution and the isotopic distribution for the undeuterated peptide (<code>isotopic_distribution</code>) as it is a sum of those variables (Claesen and Burzykowski 2017, Deconvolution-Based Approach). Namely <span class="math display">\[M_{\Delta} = M_{mol} - M_{mon}\]</span> where <span class="math inline">\(M_{mol}\)</span> is the random variable describing molecular mass, <span class="math inline">\(M_{mon}\)</span> is the random variable describing monoisotopic mass and <span class="math inline">\(M_{\Delta}\)</span> is the random variable describing the increase in mass.</p></li>
</ul>
<p>The function <code>get_observed_iso_dist</code> returns a vector of observed isotopic distribution (<code>observed_dist</code>) and the observed peaks for mass spectrum (observed isotopic probabilities).</p>
<p>The <span class="math inline">\(m/z\)</span> values for the deuterated peptide are calculated using the <code>peptide_mass</code>, <code>charge</code> and constants - deuteron mass (<span class="math inline">\(1.00628\)</span>) and proton mass (<span class="math inline">\(1.007276\)</span>). Starting from the <span class="math inline">\(m/z\)</span> value for the monoisotopic peak, the difference between the mass of deuteron and proton divided by the charge of the peptide ion is added.</p>
<p>The output of the function <code>get_iso_probs_deut</code> is a data frame with the variables: Exposure (time point of measurement consistent with given HD matrix), Mz - <span class="math inline">\(m/z\)</span> values, Intensity - isotopic probabilities and PH - pH.</p>
</div>
<div id="prepare-the-final-result-" class="section level4">
<h4 class="hasAnchor">
<a href="#prepare-the-final-result-" class="anchor"></a>Prepare the final result.</h4>
<p>To the calculated results is added a minimal exchange control - for time point 0. The <span class="math inline">\(m/z\)</span> values are obtained as a ratio of the <code>peptide_mass</code> magnified by proton mass and the peptide charge. The distribution of undeuterated peptide from the previous section is the intensities vector.</p>
<p>The output of the function <code>simulate_theoretical_spectra</code> is a data table of:</p>
<ul>
<li>
<code>Exposure</code> - time point of a measurement,</li>
<li>
<code>Mz</code> - mass-to-charge ratio,</li>
<li>
<code>Intensity</code> - isotopic probabilities larger than <code>min_probability</code> (the smaller ones are zeroes)</li>
</ul>
<p>and the variables provided by user</p>
<ul>
<li>
<code>Sequence</code>,</li>
<li>
<code>PF</code>,</li>
<li>
<code>Charge</code>,</li>
<li>
<code>PH</code>.</li>
</ul>
<p>As in the table below</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">spectrum1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/simulate_theoretical_spectra.html">simulate_theoretical_spectra</a></span><span class="op">(</span><span class="st">"LVRKDLQN"</span>, protection_factor <span class="op">=</span> <span class="fl">10</span>, charge <span class="op">=</span> <span class="fl">2</span>, times <span class="op">=</span> <span class="fl">60</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">spectrum1</span><span class="op">)</span>
<span class="co">#&gt;    Exposure  PH    Intensity       Mz Charge Sequence PF</span>
<span class="co">#&gt; 1:        0 7.5 0.5801405135 493.2931      2 LVRKDLQN 10</span>
<span class="co">#&gt; 2:        0 7.5 0.3031692943 493.2931      2 LVRKDLQN 10</span>
<span class="co">#&gt; 3:        0 7.5 0.0919265899 493.2931      2 LVRKDLQN 10</span>
<span class="co">#&gt; 4:        0 7.5 0.0204531418 493.2931      2 LVRKDLQN 10</span>
<span class="co">#&gt; 5:        0 7.5 0.0036689790 493.2931      2 LVRKDLQN 10</span>
<span class="co">#&gt; 6:        0 7.5 0.0005576524 493.2931      2 LVRKDLQN 10</span></code></pre></div>
<p>The data obtained by the procedure described above is called the theoretical spectrum. Let us note that a single spectrum is observed for a particular set of parameters such as <code>Exposure</code>, <code>Sequence</code>, <code>PF</code>, <code>Charge</code>, <code>PH</code>. Thus, using the option of providing a vector of time points and/or charges, one obtains several spectra.</p>
<p>Such a spectrum is the first step of the simulation shown in the first diagram when simulated for two biological states and different time points.</p>
</div>
</div>
</div>
<div id="add-noise-to-the-theoretical-spectrum" class="section level2">
<h2 class="hasAnchor">
<a href="#add-noise-to-the-theoretical-spectrum" class="anchor"></a>2. Add noise to the theoretical spectrum</h2>
<div id="add-noise-to-the-theoretical-spectrum-1" class="section level4">
<h4 class="hasAnchor">
<a href="#add-noise-to-the-theoretical-spectrum-1" class="anchor"></a>Add noise to the theoretical spectrum</h4>
<p>To imitate the data from the HDX experiments one may use the function named <code>get_noisy_deuteration_curves</code> from the file <code>noisy_spectra.R</code> that creates spectra with technical replicates and noise. The function takes the following parameters:</p>
<ul>
<li><p><code>theoretical_spectra</code> - a data table of theoretical spectra created by the function<code>simulate_theoretical_spectra</code> and grouped by <code>sequence</code>, <code>pH</code> and <code>PF</code>. See <strong>Simulate theoretical spectrum</strong> section.</p></li>
<li><p><code>compare_pairs</code> - logical. If FALSE, all groups (defined by the protection factor) will be considered jointly. If TRUE (default), each protection factor will be considered together with the protection factor given by the <code>reference</code> parameter.</p></li>
<li><p><code>reference</code> - protection factor that will be used for comparison to other protection factors. The function accepts either NA (for comparing all protection factors jointly), a number (for comparing with reference value of protection factor) or <code>"all"</code> (for pairwise comparisons of all the possible combinations). Default NA.</p></li>
<li><p><code>n_replicates</code> - number of technical replicates to create.</p></li>
<li><p><code>n_experiments</code> - number of replicates of curves for power calculation.</p></li>
<li><p><code>mass_deviations</code> - mass deviation in parts per million. Either a single number (then the error at each time point will be the same) or a vector of the same length as the number of unique time points in the experiment. The error will be sampled from normal distribution with standard deviation equal to <span class="math display">\[\dfrac{mass\_deviations\cdot undeuterated\_mass}{10^6}\]</span></p></li>
<li><p><code>intensity_deviations</code> - optional, standard deviations of random noise that will be added to intensities. Either a single number (then the error at each time point will be the same) or a vector of the same length as the number of unique time points in the experiment. The error will be simulated with these standard deviations. Default <span class="math inline">\(NULL\)</span>.</p></li>
<li><p><code>per_run_deviations</code> - optional, standard deviations of random noise that will be added to deuteration curves. Either a single number (then the error at each time point will be the same) or a vector of the same length as the number of unique time points in the experiment. The error will be sampled from a normal distribution with these standard deviations. Default <span class="math inline">\(NULL\)</span>.</p></li>
<li><p><code>relative</code> - logical, if TRUE (default), each deuteration curve will start at 0 (relative mass will be returned). Default TRUE.</p></li>
</ul>
<p>The function <code>get_noisy_deuteration_curves</code> uses the following internal functions: - <code>get_undeuterated_mass</code> - <code>get_spectra_list</code> - <code>add_noise_to_spectra</code> - <code>get_deuteration_curves_from_spectra</code> - <code>add_noise_to_curves</code> - <code>fix_columns_names_types</code> The procedure of adding noise is the continuation of the simulation algorithm which can be seen in the first diagram. The detailed description is shown below.</p>
</div>
<div id="prepare-parameters-" class="section level4">
<h4 class="hasAnchor">
<a href="#prepare-parameters-" class="anchor"></a>Prepare parameters.</h4>
<p>Firstly, the undeuterated mass is obtained via <code>get_undeuterated_mass</code> function. The necessary parameter is the table of theoretical spectra created by the function <code>simulate_theoretical_spectra</code>. The following formula is used for the calculation: <span class="math display">\[undeuterated\_mass = charge \cdot (Mz - p_m)\]</span> where <code>Mz</code> is mass-to-charge ratio for the peaks from the provided theoretical spectrum and <span class="math inline">\(p_m\)</span> is the mass of proton. The output of <code>get_undeuterated_mass</code> is the calculated mass value for the first peak (the smallest one) as it is usually the peak corresponding to the monoisotopic mass.</p>
<p>The parameters <code>theoretical_spectra</code> (produced by simulate theoretical spectra function), <code>compare_pairs</code> (as described before) and <code>reference</code> (protection factor, as described before) are passed to the <code>get_spectra_list</code> function. If the parameter <code>compare_pairs</code> is FALSE then all the provided protection factors will be considered jointly. If <code>compare_pairs</code> is TRUE, then the parameter <code>reference</code> is necessary (a single number or <code>"all"</code>). Then the data is split via the supplementary function <code>get_paired_spectra</code> into data tables of spectra with paired biological states (the reference protection factor and the protection factor of interest if provided, or all the possible pairs if <code>reference</code> equals <code>"all"</code>). The function <code>get_spectra_list</code> returns a list of data tables containing spectra - for paired states or all states.</p>
</div>
<div id="add-noise-to-spectra-" class="section level4">
<h4 class="hasAnchor">
<a href="#add-noise-to-spectra-" class="anchor"></a>Add noise to spectra.</h4>
<p>Noisy spectra are obtained from the function <code>add_noise_to_spectra</code>. It takes the parameters <code>spectra</code> (the output of <code>get_spectra_list</code>), <code>n_replicates</code>, <code>n_experiments</code>, <code>undeuterated_mass</code> (calculated by <code>get_undeuterated_mass</code>), <code>mass_deviations</code> and <code>intensity_deviations</code> (those parameters are described before).</p>
<p>Firstly, an internal function <code>make_experimental_design</code> is used to prepare technical replicates from the provided spectra. Next, for each replicate the noise is added by the function <code>make_noisy_spectra</code>. It uses the supplementary function that adds the noise to a single replicate - <code>add_noise_to_one_spectrum</code>. Standard deviations are calculated by the formula:</p>
<p><span class="math display">\[sd = \dfrac{mass\_deviations \cdot undeuterated\_mass}{10^6}\]</span></p>
<p>There are two functions that add calculated deviations to a spectrum:</p>
<ul>
<li><p><code>add_noise_to_one_timepoint</code> - the noise is sampled from a normal distribution with mean 0 and standard deviation equal to <span class="math inline">\(sd\)</span> and added to <code>Mz</code> values for the time points (based on supplied parameters for time points).</p></li>
<li><p><code>add_noise_to_intensities</code> - if the <code>intensity_deviations</code> were provided, then noise is sampled from a normal distribution with mean 0 and standard deviation equal to those deviations and added to <code>Intensity</code>.</p></li>
</ul>
<p>Having noisy spectra, the noisy deuterium uptake curves for power estimation can be obtained. Firstly, deuteration curves are calculated from spectra. It is done by the function <code>get_deuteration_curves_from_spectra</code>. The function uses the <code>spectra</code> returned by the function <code>add_noise_to_spectra</code>. From each replicated spectrum one deuteration curve is obtained via <code>get_deuteration_curve_single_spectrum</code> function. The centroid mass value from spectrum is calculated as a weighted mean from peaks based on the formula</p>
<p><span class="math display">\[m = \dfrac{1}{N}\sum_{k= 1}^N Intensity_k \cdot Charge \cdot  (Mz_k -p_m).\]</span></p>
<p>Next, the function <code>add_noise_to_curves</code> uses the supplementary function named <code>add_noise_to_single_curve</code> in order to make noisy deuteration curves (noise added to noisy uptake curves for power calculation purposes). It takes the parameters <code>curves</code> obtained from <code>get_deuteration_curves_from_spectra</code> and the parameters provided at the beginning of the simulation: <code>per_run_deviations</code> and <code>relative</code>. The noise is added by <code>add_noise</code> function. There, noise is sampled from normal distribution with mean 0 and standard deviation equal to <code>per_run_deviations</code> and added to the <code>Mass</code> values unless they are not zeroes (there is no noise at the time 0).</p>
<p>When <code>relative</code> equals TRUE, the relative mass is returned in deuteration curves (as a form of uptake). It is calculated via the function <code>get_relative_mass</code>.</p>
<p>The function <code>get_noisy_deuteration_curves</code> returns a list (for paired states when <code>compare_pairs</code> is TRUE) of lists (repetitions of experiment for power calculations) of data tables of the variables:</p>
<ul>
<li>
<code>sequence</code> - provided amino acid sequence</li>
<li>
<code>Rep</code> - technical replication</li>
<li>
<code>State</code> - provided protection factor (the theoretical - in practice unknown - state of the protein)</li>
<li><code>Exposure</code></li>
<li>
<code>Mass</code> - mass or deuterium uptake when <code>relative</code> is TRUE.</li>
<li><code>charge</code></li>
<li>
<code>Experimental_state</code> - the biological state (from the viewpoint of the experimenter) when <code>compare_pairs</code> is TRUE</li>
</ul>
<p>as shown below</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R">
<span class="va">spectrum2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/simulate_theoretical_spectra.html">simulate_theoretical_spectra</a></span><span class="op">(</span><span class="st">"LVRKDLQN"</span>, protection_factor <span class="op">=</span> <span class="fl">1000</span>, charge <span class="op">=</span> <span class="fl">2</span>, times <span class="op">=</span> <span class="fl">60</span><span class="op">)</span>
<span class="va">paired_spectra</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">spectrum1</span>, <span class="va">spectrum2</span><span class="op">)</span>

<span class="fu"><a href="../reference/get_noisy_deuteration_curves.html">get_noisy_deuteration_curves</a></span><span class="op">(</span><span class="va">paired_spectra</span>,
                             n_replicates <span class="op">=</span> <span class="fl">4</span>,
                             n_experiments <span class="op">=</span> <span class="fl">1</span>,
                             reference <span class="op">=</span> <span class="st">"all"</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>
<span class="co">#&gt;     Sequence Rep State Exposure     Mass Charge Experimental_state</span>
<span class="co">#&gt;  1: LVRKDLQN   1    10        0 0.000000      2                  A</span>
<span class="co">#&gt;  2: LVRKDLQN   1    10       60 1.501795      2                  A</span>
<span class="co">#&gt;  3: LVRKDLQN   1  1000        0 0.000000      2                  B</span>
<span class="co">#&gt;  4: LVRKDLQN   1  1000       60 1.113425      2                  B</span>
<span class="co">#&gt;  5: LVRKDLQN   2    10        0 0.000000      2                  A</span>
<span class="co">#&gt;  6: LVRKDLQN   2    10       60 1.638433      2                  A</span>
<span class="co">#&gt;  7: LVRKDLQN   2  1000        0 0.000000      2                  B</span>
<span class="co">#&gt;  8: LVRKDLQN   2  1000       60 1.124357      2                  B</span>
<span class="co">#&gt;  9: LVRKDLQN   3    10        0 0.000000      2                  A</span>
<span class="co">#&gt; 10: LVRKDLQN   3    10       60 1.666049      2                  A</span>
<span class="co">#&gt; 11: LVRKDLQN   3  1000        0 0.000000      2                  B</span>
<span class="co">#&gt; 12: LVRKDLQN   3  1000       60 1.244287      2                  B</span>
<span class="co">#&gt; 13: LVRKDLQN   4    10        0 0.000000      2                  A</span>
<span class="co">#&gt; 14: LVRKDLQN   4    10       60 1.473632      2                  A</span>
<span class="co">#&gt; 15: LVRKDLQN   4  1000        0 0.000000      2                  B</span>
<span class="co">#&gt; 16: LVRKDLQN   4  1000       60 1.108281      2                  B</span></code></pre></div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Krystyna Grzesiak.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
